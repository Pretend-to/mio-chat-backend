{"version":3,"file":"emoji-BVjhSaBE.js","sources":["../../../node_modules/.pnpm/emoji-picker-element@1.21.3/node_modules/emoji-picker-element/database.js","../../../node_modules/.pnpm/emoji-picker-element@1.21.3/node_modules/emoji-picker-element/picker.js"],"sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openIndexedDBRequests = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openIndexedDBRequests[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openIndexedDBRequests[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openIndexedDBRequests[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/â€™/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n//\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 pnpm build:rollup && pnpm test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\nconst isFirefoxContentScript = typeof wrappedJSObject !== 'undefined';\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  // if inside a Firefox content script, need to clone the emoji object to prevent Firefox from complaining about\n  // cross-origin object. See: https://github.com/nolanlawson/emoji-picker-element/issues/356\n  /* istanbul ignore if */\n  if (isFirefoxContentScript) {\n    emoji = structuredClone(emoji);\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n// even with --excludePrivate Â¯\\_(ãƒ„)_/Â¯\n/** @private */\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  let inBuffer = binaryStringToArrayBuffer(inString);\n\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n","import Database from './database.js';\n\n// via https://unpkg.com/browse/emojibase-data@6.0.0/meta/groups.json\nconst allGroups = [\n  [-1, 'âœ¨', 'custom'],\n  [0, 'ðŸ˜€', 'smileys-emotion'],\n  [1, 'ðŸ‘‹', 'people-body'],\n  [3, 'ðŸ±', 'animals-nature'],\n  [4, 'ðŸŽ', 'food-drink'],\n  [5, 'ðŸ ï¸', 'travel-places'],\n  [6, 'âš½', 'activities'],\n  [7, 'ðŸ“', 'objects'],\n  [8, 'â›”ï¸', 'symbols'],\n  [9, 'ðŸ', 'flags']\n].map(([id, emoji, name]) => ({ id, emoji, name }));\n\nconst groups = allGroups.slice(1);\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\nconst NUM_SKIN_TONES = 6;\n\n/* istanbul ignore next */\nconst rIC = typeof requestIdleCallback === 'function' ? requestIdleCallback : setTimeout;\n\n// check for ZWJ (zero width joiner) character\nfunction hasZwj (emoji) {\n  return emoji.unicode.includes('\\u200d')\n}\n\n// Find one good representative emoji from each version to test by checking its color.\n// Ideally it should have color in the center. For some inspiration, see:\n// https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n//\n// Note that for certain versions (12.1, 13.1), there is no point in testing them explicitly, because\n// all the emoji from this version are compound-emoji from previous versions. So they would pass a color\n// test, even in browsers that display them as double emoji. (E.g. \"face in clouds\" might render as\n// \"face without mouth\" plus \"fog\".) These emoji can only be filtered using the width test,\n// which happens in checkZwjSupport.js.\nconst versionsAndTestEmoji = {\n  'ðŸ«¨': 15.1, // shaking head, technically from v15 but see note above\n  'ðŸ« ': 14,\n  'ðŸ¥²': 13.1, // smiling face with tear, technically from v13 but see note above\n  'ðŸ¥»': 12.1, // sari, technically from v12 but see note above\n  'ðŸ¥°': 11,\n  'ðŸ¤©': 5,\n  'ðŸ‘±â€â™€ï¸': 4,\n  'ðŸ¤£': 3,\n  'ðŸ‘ï¸â€ðŸ—¨ï¸': 2,\n  'ðŸ˜€': 1,\n  'ðŸ˜ï¸': 0.7,\n  'ðŸ˜ƒ': 0.6\n};\n\nconst TIMEOUT_BEFORE_LOADING_MESSAGE = 1000; // 1 second\nconst DEFAULT_SKIN_TONE_EMOJI = 'ðŸ–ï¸';\nconst DEFAULT_NUM_COLUMNS = 8;\n\n// Based on https://fivethirtyeight.com/features/the-100-most-used-emojis/ and\n// https://blog.emojipedia.org/facebook-reveals-most-and-least-used-emojis/ with\n// a bit of my own curation. (E.g. avoid the \"OK\" gesture because of connotations:\n// https://emojipedia.org/ok-hand/)\nconst MOST_COMMONLY_USED_EMOJI = [\n  'ðŸ˜Š',\n  'ðŸ˜’',\n  'â¤ï¸',\n  'ðŸ‘ï¸',\n  'ðŸ˜',\n  'ðŸ˜‚',\n  'ðŸ˜­',\n  'â˜ºï¸',\n  'ðŸ˜”',\n  'ðŸ˜©',\n  'ðŸ˜',\n  'ðŸ’•',\n  'ðŸ™Œ',\n  'ðŸ˜˜'\n];\n\n// It's important to list Twemoji Mozilla before everything else, because Mozilla bundles their\n// own font on some platforms (notably Windows and Linux as of this writing). Typically, Mozilla\n// updates faster than the underlying OS, and we don't want to render older emoji in one font and\n// newer emoji in another font:\n// https://github.com/nolanlawson/emoji-picker-element/pull/268#issuecomment-1073347283\nconst FONT_FAMILY = '\"Twemoji Mozilla\",\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",' +\n  '\"Noto Color Emoji\",\"EmojiOne Color\",\"Android Emoji\",sans-serif';\n\n/* istanbul ignore next */\nconst DEFAULT_CATEGORY_SORTING = (a, b) => a < b ? -1 : a > b ? 1 : 0;\n\n// Test if an emoji is supported by rendering it to canvas and checking that the color is not black\n// See https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n// and https://www.npmjs.com/package/if-emoji for inspiration\n// This implementation is largely borrowed from if-emoji, adding the font-family\n\n\nconst getTextFeature = (text, color) => {\n  const canvas = document.createElement('canvas');\n  canvas.width = canvas.height = 1;\n\n  const ctx = canvas.getContext('2d');\n  ctx.textBaseline = 'top';\n  ctx.font = `100px ${FONT_FAMILY}`;\n  ctx.fillStyle = color;\n  ctx.scale(0.01, 0.01);\n  ctx.fillText(text, 0, 0);\n\n  return ctx.getImageData(0, 0, 1, 1).data\n};\n\nconst compareFeatures = (feature1, feature2) => {\n  const feature1Str = [...feature1].join(',');\n  const feature2Str = [...feature2].join(',');\n  // This is RGBA, so for 0,0,0, we are checking that the first RGB is not all zeroes.\n  // Most of the time when unsupported this is 0,0,0,0, but on Chrome on Mac it is\n  // 0,0,0,61 - there is a transparency here.\n  return feature1Str === feature2Str && !feature1Str.startsWith('0,0,0,')\n};\n\nfunction testColorEmojiSupported (text) {\n  // Render white and black and then compare them to each other and ensure they're the same\n  // color, and neither one is black. This shows that the emoji was rendered in color.\n  const feature1 = getTextFeature(text, '#000');\n  const feature2 = getTextFeature(text, '#fff');\n  return feature1 && feature2 && compareFeatures(feature1, feature2)\n}\n\n// rather than check every emoji ever, which would be expensive, just check some representatives from the\n// different emoji releases to determine what the font supports\n\nfunction determineEmojiSupportLevel () {\n  const entries = Object.entries(versionsAndTestEmoji);\n  try {\n    // start with latest emoji and work backwards\n    for (const [emoji, version] of entries) {\n      if (testColorEmojiSupported(emoji)) {\n        return version\n      }\n    }\n  } catch (e) { // canvas error\n  } finally {\n  }\n  // In case of an error, be generous and just assume all emoji are supported (e.g. for canvas errors\n  // due to anti-fingerprinting add-ons). Better to show some gray boxes than nothing at all.\n  return entries[0][1] // first one in the list is the most recent version\n}\n\n// Check which emojis we know for sure aren't supported, based on Unicode version level\nlet promise;\nconst detectEmojiSupportLevel = () => {\n  if (!promise) {\n    // Delay so it can run while the IDB database is being created by the browser (on another thread).\n    // This helps especially with first load â€“ we want to start pre-populating the database on the main thread,\n    // and then wait for IDB to commit everything, and while waiting we run this check.\n    promise = new Promise(resolve => (\n      rIC(() => (\n        resolve(determineEmojiSupportLevel()) // delay so ideally this can run while IDB is first populating\n      ))\n    ));\n  }\n  return promise\n};\n// determine which emojis containing ZWJ (zero width joiner) characters\n// are supported (rendered as one glyph) rather than unsupported (rendered as two or more glyphs)\nconst supportedZwjEmojis = new Map();\n\nconst VARIATION_SELECTOR = '\\ufe0f';\nconst SKINTONE_MODIFIER = '\\ud83c';\nconst ZWJ = '\\u200d';\nconst LIGHT_SKIN_TONE = 0x1F3FB;\nconst LIGHT_SKIN_TONE_MODIFIER = 0xdffb;\n\n// TODO: this is a naive implementation, we can improve it later\n// It's only used for the skintone picker, so as long as people don't customize with\n// really exotic emoji then it should work fine\nfunction applySkinTone (str, skinTone) {\n  if (skinTone === 0) {\n    return str\n  }\n  const zwjIndex = str.indexOf(ZWJ);\n  if (zwjIndex !== -1) {\n    return str.substring(0, zwjIndex) +\n      String.fromCodePoint(LIGHT_SKIN_TONE + skinTone - 1) +\n      str.substring(zwjIndex)\n  }\n  if (str.endsWith(VARIATION_SELECTOR)) {\n    str = str.substring(0, str.length - 1);\n  }\n  return str + SKINTONE_MODIFIER + String.fromCodePoint(LIGHT_SKIN_TONE_MODIFIER + skinTone - 1)\n}\n\nfunction halt (event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\n// Implementation left/right or up/down navigation, circling back when you\n// reach the start/end of the list\nfunction incrementOrDecrement (decrement, val, arr) {\n  val += (decrement ? -1 : 1);\n  if (val < 0) {\n    val = arr.length - 1;\n  } else if (val >= arr.length) {\n    val = 0;\n  }\n  return val\n}\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\n// We don't need all the data on every emoji, and there are specific things we need\n// for the UI, so build a \"view model\" from the emoji object we got from the database\n\nfunction summarizeEmojisForUI (emojis, emojiSupportLevel) {\n  const toSimpleSkinsMap = skins => {\n    const res = {};\n    for (const skin of skins) {\n      // ignore arrays like [1, 2] with multiple skin tones\n      // also ignore variants that are in an unsupported emoji version\n      // (these do exist - variants from a different version than their base emoji)\n      if (typeof skin.tone === 'number' && skin.version <= emojiSupportLevel) {\n        res[skin.tone] = skin.unicode;\n      }\n    }\n    return res\n  };\n\n  return emojis.map(({ unicode, skins, shortcodes, url, name, category, annotation }) => ({\n    unicode,\n    name,\n    shortcodes,\n    url,\n    category,\n    annotation,\n    id: unicode || name,\n    skins: skins && toSimpleSkinsMap(skins)\n  }))\n}\n\n// import rAF from one place so that the bundle size is a bit smaller\nconst rAF = requestAnimationFrame;\n\n// Svelte action to calculate the width of an element and auto-update\n// using ResizeObserver. If ResizeObserver is unsupported, we just use rAF once\n// and don't bother to update.\n\n\nlet resizeObserverSupported = typeof ResizeObserver === 'function';\n\nfunction calculateWidth (node, abortSignal, onUpdate) {\n  let resizeObserver;\n  if (resizeObserverSupported) {\n    resizeObserver = new ResizeObserver(entries => (\n      onUpdate(entries[0].contentRect.width)\n    ));\n    resizeObserver.observe(node);\n  } else { // just set the width once, don't bother trying to track it\n    rAF(() => (\n      onUpdate(node.getBoundingClientRect().width)\n    ));\n  }\n\n  // cleanup function (called on destroy)\n  abortSignal.addEventListener('abort', () => {\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n    }\n  });\n}\n\n// get the width of the text inside of a DOM node, via https://stackoverflow.com/a/59525891/680742\nfunction calculateTextWidth (node) {\n  /* istanbul ignore else */\n  {\n    const range = document.createRange();\n    range.selectNode(node.firstChild);\n    return range.getBoundingClientRect().width\n  }\n}\n\nlet baselineEmojiWidth;\n\nfunction checkZwjSupport (zwjEmojisToCheck, baselineEmoji, emojiToDomNode) {\n  for (const emoji of zwjEmojisToCheck) {\n    const domNode = emojiToDomNode(emoji);\n    const emojiWidth = calculateTextWidth(domNode);\n    if (typeof baselineEmojiWidth === 'undefined') { // calculate the baseline emoji width only once\n      baselineEmojiWidth = calculateTextWidth(baselineEmoji);\n    }\n    // On Windows, some supported emoji are ~50% bigger than the baseline emoji, but what we really want to guard\n    // against are the ones that are 2x the size, because those are truly broken (person with red hair = person with\n    // floating red wig, black cat = cat with black square, polar bear = bear with snowflake, etc.)\n    // So here we set the threshold at 1.8 times the size of the baseline emoji.\n    const supported = emojiWidth / 1.8 < baselineEmojiWidth;\n    supportedZwjEmojis.set(emoji.unicode, supported);\n  }\n}\n\n// like lodash's uniq\n\nfunction uniq (arr) {\n  return uniqBy(arr, _ => _)\n}\n\n// Note we put this in its own function outside Picker.js to avoid Svelte doing an invalidation on the \"setter\" here.\n// At best the invalidation is useless, at worst it can cause infinite loops:\n// https://github.com/nolanlawson/emoji-picker-element/pull/180\n// https://github.com/sveltejs/svelte/issues/6521\n// Also note tabpanelElement can be null if the element is disconnected immediately after connected\nfunction resetScrollTopIfPossible (element) {\n  /* istanbul ignore else */\n  if (element) { // Makes me nervous not to have this `if` guard\n    element.scrollTop = 0;\n  }\n}\n\nfunction getFromMap (cache, key, func) {\n  let cached = cache.get(key);\n  if (!cached) {\n    cached = func();\n    cache.set(key, cached);\n  }\n  return cached\n}\n\nfunction toString (value) {\n  return '' + value\n}\n\nfunction parseTemplate (htmlString) {\n  const template = document.createElement('template');\n  template.innerHTML = htmlString;\n  return template\n}\n\nconst parseCache = new WeakMap();\nconst domInstancesCache = new WeakMap();\n// This needs to be a symbol because it needs to be different from any possible output of a key function\nconst unkeyedSymbol = Symbol('un-keyed');\n\n// Not supported in Safari <=13\nconst hasReplaceChildren = 'replaceChildren' in Element.prototype;\nfunction replaceChildren (parentNode, newChildren) {\n  /* istanbul ignore else */\n  if (hasReplaceChildren) {\n    parentNode.replaceChildren(...newChildren);\n  } else { // minimal polyfill for Element.prototype.replaceChildren\n    parentNode.innerHTML = '';\n    parentNode.append(...newChildren);\n  }\n}\n\nfunction doChildrenNeedRerender (parentNode, newChildren) {\n  let oldChild = parentNode.firstChild;\n  let oldChildrenCount = 0;\n  // iterate using firstChild/nextSibling because browsers use a linked list under the hood\n  while (oldChild) {\n    const newChild = newChildren[oldChildrenCount];\n    // check if the old child and new child are the same\n    if (newChild !== oldChild) {\n      return true\n    }\n    oldChild = oldChild.nextSibling;\n    oldChildrenCount++;\n  }\n  // if new children length is different from old, we must re-render\n  return oldChildrenCount !== newChildren.length\n}\n\nfunction patchChildren (newChildren, instanceBinding) {\n  const { targetNode } = instanceBinding;\n  let { targetParentNode } = instanceBinding;\n\n  let needsRerender = false;\n\n  if (targetParentNode) { // already rendered once\n    needsRerender = doChildrenNeedRerender(targetParentNode, newChildren);\n  } else { // first render of list\n    needsRerender = true;\n    instanceBinding.targetNode = undefined; // placeholder node not needed anymore, free memory\n    instanceBinding.targetParentNode = targetParentNode = targetNode.parentNode;\n  }\n  // avoid re-rendering list if the dom nodes are exactly the same before and after\n  if (needsRerender) {\n    replaceChildren(targetParentNode, newChildren);\n  }\n}\n\nfunction patch (expressions, instanceBindings) {\n  for (const instanceBinding of instanceBindings) {\n    const {\n      targetNode,\n      currentExpression,\n      binding: {\n        expressionIndex,\n        attributeName,\n        attributeValuePre,\n        attributeValuePost\n      }\n    } = instanceBinding;\n\n    const expression = expressions[expressionIndex];\n\n    if (currentExpression === expression) {\n      // no need to update, same as before\n      continue\n    }\n\n    instanceBinding.currentExpression = expression;\n\n    if (attributeName) { // attribute replacement\n      targetNode.setAttribute(attributeName, attributeValuePre + toString(expression) + attributeValuePost);\n    } else { // text node / child element / children replacement\n      let newNode;\n      if (Array.isArray(expression)) { // array of DOM elements produced by tag template literals\n        patchChildren(expression, instanceBinding);\n      } else if (expression instanceof Element) { // html tag template returning a DOM element\n        newNode = expression;\n        targetNode.replaceWith(newNode);\n      } else { // primitive - string, number, etc\n        // nodeValue is faster than textContent supposedly https://www.youtube.com/watch?v=LY6y3HbDVmg\n        // note we may be replacing the value in a placeholder text node\n        targetNode.nodeValue = toString(expression);\n      }\n      if (newNode) {\n        instanceBinding.targetNode = newNode;\n      }\n    }\n  }\n}\n\nfunction parse (tokens) {\n  let htmlString = '';\n\n  let withinTag = false;\n  let withinAttribute = false;\n  let elementIndexCounter = -1; // depth-first traversal order\n\n  const elementsToBindings = new Map();\n  const elementIndexes = [];\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const token = tokens[i];\n    htmlString += token;\n\n    if (i === len - 1) {\n      break // no need to process characters - no more expressions to be found\n    }\n\n    for (let j = 0; j < token.length; j++) {\n      const char = token.charAt(j);\n      switch (char) {\n        case '<': {\n          const nextChar = token.charAt(j + 1);\n          if (nextChar === '/') { // closing tag\n            // leaving an element\n            elementIndexes.pop();\n          } else { // not a closing tag\n            withinTag = true;\n            elementIndexes.push(++elementIndexCounter);\n          }\n          break\n        }\n        case '>': {\n          withinTag = false;\n          withinAttribute = false;\n          break\n        }\n        case '=': {\n          withinAttribute = true;\n          break\n        }\n      }\n    }\n\n    const elementIndex = elementIndexes[elementIndexes.length - 1];\n    const bindings = getFromMap(elementsToBindings, elementIndex, () => []);\n\n    let attributeName;\n    let attributeValuePre;\n    let attributeValuePost;\n    if (withinAttribute) {\n      // I never use single-quotes for attribute values in HTML, so just support double-quotes or no-quotes\n      const match = /(\\S+)=\"?([^\"=]*)$/.exec(token);\n      attributeName = match[1];\n      attributeValuePre = match[2];\n      attributeValuePost = /^[^\">]*/.exec(tokens[i + 1])[0];\n    }\n\n    const binding = {\n      attributeName,\n      attributeValuePre,\n      attributeValuePost,\n      expressionIndex: i\n    };\n\n    bindings.push(binding);\n\n    if (!withinTag && !withinAttribute) {\n      // Add a placeholder text node, so we can find it later. Note we only support one dynamic child text node\n      htmlString += ' ';\n    }\n  }\n\n  const template = parseTemplate(htmlString);\n\n  return {\n    template,\n    elementsToBindings\n  }\n}\n\nfunction traverseAndSetupBindings (dom, elementsToBindings) {\n  const instanceBindings = [];\n  // traverse dom\n  const treeWalker = document.createTreeWalker(dom, NodeFilter.SHOW_ELEMENT);\n\n  let element = dom;\n  let elementIndex = -1;\n  do {\n    const bindings = elementsToBindings.get(++elementIndex);\n    if (bindings) {\n      for (let i = 0; i < bindings.length; i++) {\n        const binding = bindings[i];\n\n        const targetNode = binding.attributeName\n          ? element // attribute binding, just use the element itself\n          : element.firstChild; // not an attribute binding, so has a placeholder text node\n\n        const instanceBinding = {\n          binding,\n          targetNode,\n          targetParentNode: undefined,\n          currentExpression: undefined\n        };\n\n        instanceBindings.push(instanceBinding);\n      }\n    }\n  } while ((element = treeWalker.nextNode()))\n\n  return instanceBindings\n}\n\nfunction parseHtml (tokens) {\n  // All templates and bound expressions are unique per tokens array\n  const { template, elementsToBindings } = getFromMap(parseCache, tokens, () => parse(tokens));\n\n  // When we parseHtml, we always return a fresh DOM instance ready to be updated\n  const dom = template.cloneNode(true).content.firstElementChild;\n  const instanceBindings = traverseAndSetupBindings(dom, elementsToBindings);\n\n  return function updateDomInstance (expressions) {\n    patch(expressions, instanceBindings);\n    return dom\n  }\n}\n\nfunction createFramework (state) {\n  const domInstances = getFromMap(domInstancesCache, state, () => new Map());\n  let domInstanceCacheKey = unkeyedSymbol;\n\n  function html (tokens, ...expressions) {\n    // Each unique lexical usage of map() is considered unique due to the html`` tagged template call it makes,\n    // which has lexically unique tokens. The unkeyed symbol is just used for html`` usage outside of a map().\n    const domInstancesForTokens = getFromMap(domInstances, tokens, () => new Map());\n    const updateDomInstance = getFromMap(domInstancesForTokens, domInstanceCacheKey, () => parseHtml(tokens));\n\n    return updateDomInstance(expressions) // update with expressions\n  }\n\n  function map (array, callback, keyFunction) {\n    return array.map((item, index) => {\n      const originalCacheKey = domInstanceCacheKey;\n      domInstanceCacheKey = keyFunction(item);\n      try {\n        return callback(item, index)\n      } finally {\n        domInstanceCacheKey = originalCacheKey;\n      }\n    })\n  }\n\n  return { map, html }\n}\n\nfunction render (container, state, helpers, events, actions, refs, abortSignal, firstRender) {\n  const { labelWithSkin, titleForEmoji, unicodeWithSkin } = helpers;\n  const { html, map } = createFramework(state);\n\n  function emojiList (emojis, searchMode, prefix) {\n    return map(emojis, (emoji, i) => {\n      return html`<button role=\"${searchMode ? 'option' : 'menuitem'}\" aria-selected=\"${state.searchMode ? i === state.activeSearchItem : ''}\" aria-label=\"${labelWithSkin(emoji, state.currentSkinTone)}\" title=\"${titleForEmoji(emoji)}\" class=\"emoji ${searchMode && i === state.activeSearchItem ? 'active' : ''}\" id=\"${`${prefix}-${emoji.id}`}\">${\n        emoji.unicode\n          ? unicodeWithSkin(emoji, state.currentSkinTone)\n          : html`<img class=\"custom-emoji\" src=\"${emoji.url}\" alt=\"\" loading=\"lazy\">`\n      }</button>`\n      // It's important for the cache key to be unique based on the prefix, because the framework caches based on the\n      // unique tokens + cache key, and the same emoji may be used in the tab as well as in the fav bar\n    }, emoji => `${prefix}-${emoji.id}`)\n  }\n\n  const section = () => {\n    return html`<section data-ref=\"rootElement\" class=\"picker\" aria-label=\"${state.i18n.regionLabel}\" style=\"${state.pickerStyle}\"><div class=\"pad-top\"></div><div class=\"search-row\"><div class=\"search-wrapper\"><input id=\"search\" class=\"search\" type=\"search\" role=\"combobox\" enterkeyhint=\"search\" placeholder=\"${state.i18n.searchLabel}\" autocapitalize=\"none\" autocomplete=\"off\" spellcheck=\"true\" aria-expanded=\"${!!(state.searchMode && state.currentEmojis.length)}\" aria-controls=\"search-results\" aria-describedby=\"search-description\" aria-autocomplete=\"list\" aria-activedescendant=\"${state.activeSearchItemId ? `emo-${state.activeSearchItemId}` : ''}\" data-ref=\"searchElement\" data-on-input=\"onSearchInput\" data-on-keydown=\"onSearchKeydown\"><label class=\"sr-only\" for=\"search\">${state.i18n.searchLabel}</label> <span id=\"search-description\" class=\"sr-only\">${state.i18n.searchDescription}</span></div><div class=\"skintone-button-wrapper ${state.skinTonePickerExpandedAfterAnimation ? 'expanded' : ''}\"><button id=\"skintone-button\" class=\"emoji ${state.skinTonePickerExpanded ? 'hide-focus' : ''}\" aria-label=\"${state.skinToneButtonLabel}\" title=\"${state.skinToneButtonLabel}\" aria-describedby=\"skintone-description\" aria-haspopup=\"listbox\" aria-expanded=\"${state.skinTonePickerExpanded}\" aria-controls=\"skintone-list\" data-on-click=\"onClickSkinToneButton\">${state.skinToneButtonText}</button></div><span id=\"skintone-description\" class=\"sr-only\">${state.i18n.skinToneDescription}</span><div data-ref=\"skinToneDropdown\" id=\"skintone-list\" class=\"skintone-list hide-focus ${state.skinTonePickerExpanded ? '' : 'hidden no-animate'}\" style=\"transform:translateY(${state.skinTonePickerExpanded ? 0 : 'calc(-1 * var(--num-skintones) * var(--total-emoji-size))'})\" role=\"listbox\" aria-label=\"${state.i18n.skinTonesLabel}\" aria-activedescendant=\"skintone-${state.activeSkinTone}\" aria-hidden=\"${!state.skinTonePickerExpanded}\" tabIndex=\"-1\" data-on-focusout=\"onSkinToneOptionsFocusOut\" data-on-click=\"onSkinToneOptionsClick\" data-on-keydown=\"onSkinToneOptionsKeydown\" data-on-keyup=\"onSkinToneOptionsKeyup\">${\n    map(state.skinTones, (skinTone, i) => {\n    return html`<div id=\"skintone-${i}\" class=\"emoji ${i === state.activeSkinTone ? 'active' : ''}\" aria-selected=\"${i === state.activeSkinTone}\" role=\"option\" title=\"${state.i18n.skinTones[i]}\" aria-label=\"${state.i18n.skinTones[i]}\">${skinTone}</div>`\n    }, skinTone => skinTone)\n        }</div></div><div class=\"nav\" role=\"tablist\" style=\"grid-template-columns:repeat(${state.groups.length},1fr)\" aria-label=\"${state.i18n.categoriesLabel}\" data-on-keydown=\"onNavKeydown\" data-on-click=\"onNavClick\">${\n            map(state.groups, (group) => {\n              return html`<button role=\"tab\" class=\"nav-button\" aria-controls=\"tab-${group.id}\" aria-label=\"${state.i18n.categories[group.name]}\" aria-selected=\"${!state.searchMode && state.currentGroup.id === group.id}\" title=\"${state.i18n.categories[group.name]}\" data-group-id=\"${group.id}\"><div class=\"nav-emoji emoji\">${group.emoji}</div></button>`\n            }, group => group.id)\n          }</div><div class=\"indicator-wrapper\"><div class=\"indicator\" style=\"transform:translateX(${(/* istanbul ignore next */ (state.isRtl ? -1 : 1)) * state.currentGroupIndex * 100}%)\"></div></div><div class=\"message ${state.message ? '' : 'gone'}\" role=\"alert\" aria-live=\"polite\">${state.message}</div><div data-ref=\"tabpanelElement\" class=\"tabpanel ${(!state.databaseLoaded || state.message) ? 'gone' : ''}\" role=\"${state.searchMode ? 'region' : 'tabpanel'}\" aria-label=\"${state.searchMode ? state.i18n.searchResultsLabel : state.i18n.categories[state.currentGroup.name]}\" id=\"${state.searchMode ? '' : `tab-${state.currentGroup.id}`}\" tabIndex=\"0\" data-on-click=\"onEmojiClick\"><div data-action=\"calculateEmojiGridStyle\">${\n              map(state.currentEmojisWithCategories, (emojiWithCategory, i) => {\n                return html`<div><div id=\"menu-label-${i}\" class=\"category ${state.currentEmojisWithCategories.length === 1 && state.currentEmojisWithCategories[0].category === '' ? 'gone' : ''}\" aria-hidden=\"true\">${\n                  state.searchMode\n                    ? state.i18n.searchResultsLabel\n                    : (\n                      emojiWithCategory.category\n                        ? emojiWithCategory.category\n                        : (\n                          state.currentEmojisWithCategories.length > 1\n                            ? state.i18n.categories.custom\n                            : state.i18n.categories[state.currentGroup.name]\n                        )\n                    )\n                }</div><div class=\"emoji-menu\" role=\"${state.searchMode ? 'listbox' : 'menu'}\" aria-labelledby=\"menu-label-${i}\" id=\"${state.searchMode ? 'search-results' : ''}\">${\n              emojiList(emojiWithCategory.emojis, state.searchMode, /* prefix */ 'emo')\n            }</div></div>`\n              }, emojiWithCategory => emojiWithCategory.category)\n            }</div></div><div class=\"favorites emoji-menu ${state.message ? 'gone' : ''}\" role=\"menu\" aria-label=\"${state.i18n.favoritesLabel}\" style=\"padding-inline-end:${`${state.scrollbarWidth}px`}\" data-on-click=\"onEmojiClick\">${\n            emojiList(state.currentFavorites, /* searchMode */ false, /* prefix */ 'fav')\n          }</div><button data-ref=\"baselineEmoji\" aria-hidden=\"true\" tabindex=\"-1\" class=\"abs-pos hidden emoji baseline-emoji\">ðŸ˜€</button></section>`\n  };\n\n  const rootDom = section();\n\n  if (firstRender) { // not a re-render\n    container.appendChild(rootDom);\n\n    // we only bind events/refs/actions once - there is no need to find them again given this component structure\n\n    // helper for traversing the dom, finding elements by an attribute, and getting the attribute value\n    const forElementWithAttribute = (attributeName, callback) => {\n      for (const element of container.querySelectorAll(`[${attributeName}]`)) {\n        callback(element, element.getAttribute(attributeName));\n      }\n    };\n\n    // bind events\n    for (const eventName of ['click', 'focusout', 'input', 'keydown', 'keyup']) {\n      forElementWithAttribute(`data-on-${eventName}`, (element, listenerName) => {\n        element.addEventListener(eventName, events[listenerName]);\n      });\n    }\n\n    // find refs\n    forElementWithAttribute('data-ref', (element, ref) => {\n      refs[ref] = element;\n    });\n\n    // set up actions\n    forElementWithAttribute('data-action', (element, action) => {\n      actions[action](element);\n    });\n\n    // destroy/abort logic\n    abortSignal.addEventListener('abort', () => {\n      container.removeChild(rootDom);\n    });\n  }\n}\n\n/* istanbul ignore next */\nconst qM = typeof queueMicrotask === 'function' ? queueMicrotask : callback => Promise.resolve().then(callback);\n\nfunction createState (abortSignal) {\n  let destroyed = false;\n  let currentObserver;\n\n  const propsToObservers = new Map();\n  const dirtyObservers = new Set();\n\n  let queued;\n\n  const flush = () => {\n    if (destroyed) {\n      return\n    }\n    const observersToRun = [...dirtyObservers];\n    dirtyObservers.clear(); // clear before running to force any new updates to run in another tick of the loop\n    try {\n      for (const observer of observersToRun) {\n        observer();\n      }\n    } finally {\n      queued = false;\n      if (dirtyObservers.size) { // new updates, queue another one\n        queued = true;\n        qM(flush);\n      }\n    }\n  };\n\n  const state = new Proxy({}, {\n    get (target, prop) {\n      if (currentObserver) {\n        let observers = propsToObservers.get(prop);\n        if (!observers) {\n          observers = new Set();\n          propsToObservers.set(prop, observers);\n        }\n        observers.add(currentObserver);\n      }\n      return target[prop]\n    },\n    set (target, prop, newValue) {\n      target[prop] = newValue;\n      const observers = propsToObservers.get(prop);\n      if (observers) {\n        for (const observer of observers) {\n          dirtyObservers.add(observer);\n        }\n        if (!queued) {\n          queued = true;\n          qM(flush);\n        }\n      }\n      return true\n    }\n  });\n\n  const createEffect = (callback) => {\n    const runnable = () => {\n      const oldObserver = currentObserver;\n      currentObserver = runnable;\n      try {\n        return callback()\n      } finally {\n        currentObserver = oldObserver;\n      }\n    };\n    return runnable()\n  };\n\n  // destroy logic\n  abortSignal.addEventListener('abort', () => {\n    destroyed = true;\n  });\n\n  return {\n    state,\n    createEffect\n  }\n}\n\n// Compare two arrays, with a function called on each item in the two arrays that returns true if the items are equal\nfunction arraysAreEqualByFunction (left, right, areEqualFunc) {\n  if (left.length !== right.length) {\n    return false\n  }\n  for (let i = 0; i < left.length; i++) {\n    if (!areEqualFunc(left[i], right[i])) {\n      return false\n    }\n  }\n  return true\n}\n\n/* eslint-disable prefer-const,no-labels,no-inner-declarations */\n\n// constants\nconst EMPTY_ARRAY = [];\n\nconst { assign } = Object;\n\nfunction createRoot (shadowRoot, props) {\n  const refs = {};\n  const abortController = new AbortController();\n  const abortSignal = abortController.signal;\n  const { state, createEffect } = createState(abortSignal);\n\n  // initial state\n  assign(state, {\n    skinToneEmoji: undefined,\n    i18n: undefined,\n    database: undefined,\n    customEmoji: undefined,\n    customCategorySorting: undefined,\n    emojiVersion: undefined\n  });\n\n  // public props\n  assign(state, props);\n\n  // private props\n  assign(state, {\n    initialLoad: true,\n    currentEmojis: [],\n    currentEmojisWithCategories: [],\n    rawSearchText: '',\n    searchText: '',\n    searchMode: false,\n    activeSearchItem: -1,\n    message: undefined,\n    skinTonePickerExpanded: false,\n    skinTonePickerExpandedAfterAnimation: false,\n    currentSkinTone: 0,\n    activeSkinTone: 0,\n    skinToneButtonText: undefined,\n    pickerStyle: undefined,\n    skinToneButtonLabel: '',\n    skinTones: [],\n    currentFavorites: [],\n    defaultFavoriteEmojis: undefined,\n    numColumns: DEFAULT_NUM_COLUMNS,\n    isRtl: false,\n    scrollbarWidth: 0,\n    currentGroupIndex: 0,\n    groups: groups,\n    databaseLoaded: false,\n    activeSearchItemId: undefined\n  });\n\n  //\n  // Update the current group based on the currentGroupIndex\n  //\n  createEffect(() => {\n    if (state.currentGroup !== state.groups[state.currentGroupIndex]) {\n      state.currentGroup = state.groups[state.currentGroupIndex];\n    }\n  });\n\n  //\n  // Utils/helpers\n  //\n\n  const focus = id => {\n    shadowRoot.getElementById(id).focus();\n  };\n\n  const emojiToDomNode = emoji => shadowRoot.getElementById(`emo-${emoji.id}`);\n\n  // fire a custom event that crosses the shadow boundary\n  const fireEvent = (name, detail) => {\n    refs.rootElement.dispatchEvent(new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      composed: true\n    }));\n  };\n\n  //\n  // Comparison utils\n  //\n\n  const compareEmojiArrays = (a, b) => a.id === b.id;\n\n  const compareCurrentEmojisWithCategories = (a, b) => {\n    const { category: aCategory, emojis: aEmojis } = a;\n    const { category: bCategory, emojis: bEmojis } = b;\n\n    if (aCategory !== bCategory) {\n      return false\n    }\n\n    return arraysAreEqualByFunction(aEmojis, bEmojis, compareEmojiArrays)\n  };\n\n  //\n  // Update utils to avoid excessive re-renders\n  //\n\n  // avoid excessive re-renders by checking the value before setting\n  const updateCurrentEmojis = (newEmojis) => {\n    if (!arraysAreEqualByFunction(state.currentEmojis, newEmojis, compareEmojiArrays)) {\n      state.currentEmojis = newEmojis;\n    }\n  };\n\n  // avoid excessive re-renders\n  const updateSearchMode = (newSearchMode) => {\n    if (state.searchMode !== newSearchMode) {\n      state.searchMode = newSearchMode;\n    }\n  };\n\n  // avoid excessive re-renders\n  const updateCurrentEmojisWithCategories = (newEmojisWithCategories) => {\n    if (!arraysAreEqualByFunction(state.currentEmojisWithCategories, newEmojisWithCategories, compareCurrentEmojisWithCategories)) {\n      state.currentEmojisWithCategories = newEmojisWithCategories;\n    }\n  };\n\n  // Helpers used by PickerTemplate\n\n  const unicodeWithSkin = (emoji, currentSkinTone) => (\n    (currentSkinTone && emoji.skins && emoji.skins[currentSkinTone]) || emoji.unicode\n  );\n\n  const labelWithSkin = (emoji, currentSkinTone) => (\n    uniq([\n      (emoji.name || unicodeWithSkin(emoji, currentSkinTone)),\n      emoji.annotation,\n      ...(emoji.shortcodes || EMPTY_ARRAY)\n    ].filter(Boolean)).join(', ')\n  );\n\n  const titleForEmoji = (emoji) => (\n    emoji.annotation || (emoji.shortcodes || EMPTY_ARRAY).join(', ')\n  );\n\n  const helpers = {\n    labelWithSkin, titleForEmoji, unicodeWithSkin\n  };\n  const events = {\n    onClickSkinToneButton,\n    onEmojiClick,\n    onNavClick,\n    onNavKeydown,\n    onSearchKeydown,\n    onSkinToneOptionsClick,\n    onSkinToneOptionsFocusOut,\n    onSkinToneOptionsKeydown,\n    onSkinToneOptionsKeyup,\n    onSearchInput\n  };\n  const actions = {\n    calculateEmojiGridStyle\n  };\n\n  let firstRender = true;\n  createEffect(() => {\n    render(shadowRoot, state, helpers, events, actions, refs, abortSignal, firstRender);\n    firstRender = false;\n  });\n\n  //\n  // Determine the emoji support level (in requestIdleCallback)\n  //\n\n  // mount logic\n  if (!state.emojiVersion) {\n    detectEmojiSupportLevel().then(level => {\n      // Can't actually test emoji support in Jest/Vitest/JSDom, emoji never render in color in Cairo\n      /* istanbul ignore next */\n      if (!level) {\n        state.message = state.i18n.emojiUnsupportedMessage;\n      }\n    });\n  }\n\n  //\n  // Set or update the database object\n  //\n\n  createEffect(() => {\n    // show a Loading message if it takes a long time, or show an error if there's a network/IDB error\n    async function handleDatabaseLoading () {\n      let showingLoadingMessage = false;\n      const timeoutHandle = setTimeout(() => {\n        showingLoadingMessage = true;\n        state.message = state.i18n.loadingMessage;\n      }, TIMEOUT_BEFORE_LOADING_MESSAGE);\n      try {\n        await state.database.ready();\n        state.databaseLoaded = true; // eslint-disable-line no-unused-vars\n      } catch (err) {\n        console.error(err);\n        state.message = state.i18n.networkErrorMessage;\n      } finally {\n        clearTimeout(timeoutHandle);\n        if (showingLoadingMessage) { // Seems safer than checking the i18n string, which may change\n          showingLoadingMessage = false;\n          state.message = ''; // eslint-disable-line no-unused-vars\n        }\n      }\n    }\n\n    if (state.database) {\n      /* no await */\n      handleDatabaseLoading();\n    }\n  });\n\n  //\n  // Global styles for the entire picker\n  //\n\n  createEffect(() => {\n    state.pickerStyle = `\n      --num-groups: ${state.groups.length}; \n      --indicator-opacity: ${state.searchMode ? 0 : 1}; \n      --num-skintones: ${NUM_SKIN_TONES};`;\n  });\n\n  //\n  // Set or update the customEmoji\n  //\n\n  createEffect(() => {\n    if (state.customEmoji && state.database) {\n      updateCustomEmoji(); // re-run whenever customEmoji change\n    }\n  });\n\n  createEffect(() => {\n    if (state.customEmoji && state.customEmoji.length) {\n      if (state.groups !== allGroups) { // don't update unnecessarily\n        state.groups = allGroups;\n      }\n    } else if (state.groups !== groups) {\n      if (state.currentGroupIndex) {\n        // If the current group is anything other than \"custom\" (which is first), decrement.\n        // This fixes the odd case where you set customEmoji, then pick a category, then unset customEmoji\n        state.currentGroupIndex--;\n      }\n      state.groups = groups;\n    }\n  });\n\n  //\n  // Set or update the preferred skin tone\n  //\n\n  createEffect(() => {\n    async function updatePreferredSkinTone () {\n      if (state.databaseLoaded) {\n        state.currentSkinTone = await state.database.getPreferredSkinTone();\n      }\n    }\n\n    /* no await */ updatePreferredSkinTone();\n  });\n\n  createEffect(() => {\n    state.skinTones = Array(NUM_SKIN_TONES).fill().map((_, i) => applySkinTone(state.skinToneEmoji, i));\n  });\n\n  createEffect(() => {\n    state.skinToneButtonText = state.skinTones[state.currentSkinTone];\n  });\n\n  createEffect(() => {\n    state.skinToneButtonLabel = state.i18n.skinToneLabel.replace('{skinTone}', state.i18n.skinTones[state.currentSkinTone]);\n  });\n\n  //\n  // Set or update the favorites emojis\n  //\n\n  createEffect(() => {\n    async function updateDefaultFavoriteEmojis () {\n      const { database } = state;\n      const favs = (await Promise.all(MOST_COMMONLY_USED_EMOJI.map(unicode => (\n        database.getEmojiByUnicodeOrName(unicode)\n      )))).filter(Boolean); // filter because in Jest/Vitest tests we don't have all the emoji in the DB\n      state.defaultFavoriteEmojis = favs;\n    }\n\n    if (state.databaseLoaded) {\n      /* no await */ updateDefaultFavoriteEmojis();\n    }\n  });\n\n  function updateCustomEmoji () {\n    // Certain effects have an implicit dependency on customEmoji since it affects the database\n    // Getting it here on the state ensures this effect re-runs when customEmoji change.\n    // Setting it on the database is pointless but prevents this code from being removed by a minifier.\n    state.database.customEmoji = state.customEmoji || EMPTY_ARRAY;\n  }\n\n  createEffect(() => {\n    async function updateFavorites () {\n      updateCustomEmoji(); // re-run whenever customEmoji change\n      const { database, defaultFavoriteEmojis, numColumns } = state;\n      const dbFavorites = await database.getTopFavoriteEmoji(numColumns);\n      const favorites = await summarizeEmojis(uniqBy([\n        ...dbFavorites,\n        ...defaultFavoriteEmojis\n      ], _ => (_.unicode || _.name)).slice(0, numColumns));\n      state.currentFavorites = favorites;\n    }\n\n    if (state.databaseLoaded && state.defaultFavoriteEmojis) {\n      /* no await */ updateFavorites();\n    }\n  });\n\n  //\n  // Calculate the width of the emoji grid. This serves two purposes:\n  // 1) Re-calculate the --num-columns var because it may have changed\n  // 2) Re-calculate the scrollbar width because it may have changed\n  //   (i.e. because the number of items changed)\n  // 3) Re-calculate whether we're in RTL mode or not.\n  //\n  // The benefit of doing this in one place is to align with rAF/ResizeObserver\n  // and do all the calculations in one go. RTL vs LTR is not strictly width-related,\n  // but since we're already reading the style here, and since it's already aligned with\n  // the rAF loop, this is the most appropriate place to do it perf-wise.\n  //\n\n  function calculateEmojiGridStyle (node) {\n    calculateWidth(node, abortSignal, width => {\n      /* istanbul ignore next */\n      { // jsdom throws errors for this kind of fancy stuff\n        // read all the style/layout calculations we need to make\n        const style = getComputedStyle(refs.rootElement);\n        const newNumColumns = parseInt(style.getPropertyValue('--num-columns'), 10);\n        const newIsRtl = style.getPropertyValue('direction') === 'rtl';\n        const parentWidth = node.parentElement.getBoundingClientRect().width;\n        const newScrollbarWidth = parentWidth - width;\n\n        // write to state variables\n        state.numColumns = newNumColumns;\n        state.scrollbarWidth = newScrollbarWidth; // eslint-disable-line no-unused-vars\n        state.isRtl = newIsRtl; // eslint-disable-line no-unused-vars\n      }\n    });\n  }\n\n  //\n  // Set or update the currentEmojis. Check for invalid ZWJ renderings\n  // (i.e. double emoji).\n  //\n\n  createEffect(() => {\n    async function updateEmojis () {\n      const { searchText, currentGroup, databaseLoaded, customEmoji } = state;\n      if (!databaseLoaded) {\n        state.currentEmojis = [];\n        state.searchMode = false;\n      } else if (searchText.length >= MIN_SEARCH_TEXT_LENGTH) {\n        const newEmojis = await getEmojisBySearchQuery(searchText);\n        if (state.searchText === searchText) { // if the situation changes asynchronously, do not update\n          updateCurrentEmojis(newEmojis);\n          updateSearchMode(true);\n        }\n      } else { // database is loaded and we're not in search mode, so we're in normal category mode\n        const { id: currentGroupId } = currentGroup;\n        // avoid race condition where currentGroupId is -1 and customEmoji is undefined/empty\n        if (currentGroupId !== -1 || (customEmoji && customEmoji.length)) {\n          const newEmojis = await getEmojisByGroup(currentGroupId);\n          if (state.currentGroup.id === currentGroupId) { // if the situation changes asynchronously, do not update\n            updateCurrentEmojis(newEmojis);\n            updateSearchMode(false);\n          }\n        }\n      }\n    }\n\n    /* no await */ updateEmojis();\n  });\n\n  // Some emojis have their ligatures rendered as two or more consecutive emojis\n  // We want to treat these the same as unsupported emojis, so we compare their\n  // widths against the baseline widths and remove them as necessary\n  createEffect(() => {\n    const { currentEmojis, emojiVersion } = state;\n    const zwjEmojisToCheck = currentEmojis\n      .filter(emoji => emoji.unicode) // filter custom emoji\n      .filter(emoji => hasZwj(emoji) && !supportedZwjEmojis.has(emoji.unicode));\n    if (!emojiVersion && zwjEmojisToCheck.length) {\n      // render now, check their length later\n      updateCurrentEmojis(currentEmojis);\n      rAF(() => checkZwjSupportAndUpdate(zwjEmojisToCheck));\n    } else {\n      const newEmojis = emojiVersion ? currentEmojis : currentEmojis.filter(isZwjSupported);\n      updateCurrentEmojis(newEmojis);\n      // Reset scroll top to 0 when emojis change\n      rAF(() => resetScrollTopIfPossible(refs.tabpanelElement));\n    }\n  });\n\n  function checkZwjSupportAndUpdate (zwjEmojisToCheck) {\n    checkZwjSupport(zwjEmojisToCheck, refs.baselineEmoji, emojiToDomNode);\n    // force update\n    // eslint-disable-next-line no-self-assign\n    state.currentEmojis = state.currentEmojis;\n  }\n\n  function isZwjSupported (emoji) {\n    return !emoji.unicode || !hasZwj(emoji) || supportedZwjEmojis.get(emoji.unicode)\n  }\n\n  async function filterEmojisByVersion (emojis) {\n    const emojiSupportLevel = state.emojiVersion || await detectEmojiSupportLevel();\n    // !version corresponds to custom emoji\n    return emojis.filter(({ version }) => !version || version <= emojiSupportLevel)\n  }\n\n  async function summarizeEmojis (emojis) {\n    return summarizeEmojisForUI(emojis, state.emojiVersion || await detectEmojiSupportLevel())\n  }\n\n  async function getEmojisByGroup (group) {\n    // -1 is custom emoji\n    const emoji = group === -1 ? state.customEmoji : await state.database.getEmojiByGroup(group);\n    return summarizeEmojis(await filterEmojisByVersion(emoji))\n  }\n\n  async function getEmojisBySearchQuery (query) {\n    return summarizeEmojis(await filterEmojisByVersion(await state.database.getEmojiBySearchQuery(query)))\n  }\n\n  createEffect(() => {\n  });\n\n  //\n  // Derive currentEmojisWithCategories from currentEmojis. This is always done even if there\n  // are no categories, because it's just easier to code the HTML this way.\n  //\n\n  createEffect(() => {\n    function calculateCurrentEmojisWithCategories () {\n      const { searchMode, currentEmojis } = state;\n      if (searchMode) {\n        return [\n          {\n            category: '',\n            emojis: currentEmojis\n          }\n        ]\n      }\n      const categoriesToEmoji = new Map();\n      for (const emoji of currentEmojis) {\n        const category = emoji.category || '';\n        let emojis = categoriesToEmoji.get(category);\n        if (!emojis) {\n          emojis = [];\n          categoriesToEmoji.set(category, emojis);\n        }\n        emojis.push(emoji);\n      }\n      return [...categoriesToEmoji.entries()]\n        .map(([category, emojis]) => ({ category, emojis }))\n        .sort((a, b) => state.customCategorySorting(a.category, b.category))\n    }\n\n    const newEmojisWithCategories = calculateCurrentEmojisWithCategories();\n    updateCurrentEmojisWithCategories(newEmojisWithCategories);\n  });\n\n  //\n  // Handle active search item (i.e. pressing up or down while searching)\n  //\n\n  createEffect(() => {\n    state.activeSearchItemId = state.activeSearchItem !== -1 && state.currentEmojis[state.activeSearchItem].id;\n  });\n\n  //\n  // Handle user input on the search input\n  //\n\n  createEffect(() => {\n    const { rawSearchText } = state;\n    rIC(() => {\n      state.searchText = (rawSearchText || '').trim(); // defer to avoid input delays, plus we can trim here\n      state.activeSearchItem = -1;\n    });\n  });\n\n  function onSearchKeydown (event) {\n    if (!state.searchMode || !state.currentEmojis.length) {\n      return\n    }\n\n    const goToNextOrPrevious = (previous) => {\n      halt(event);\n      state.activeSearchItem = incrementOrDecrement(previous, state.activeSearchItem, state.currentEmojis);\n    };\n\n    switch (event.key) {\n      case 'ArrowDown':\n        return goToNextOrPrevious(false)\n      case 'ArrowUp':\n        return goToNextOrPrevious(true)\n      case 'Enter':\n        if (state.activeSearchItem === -1) {\n          // focus the first option in the list since the list must be non-empty at this point (it's verified above)\n          state.activeSearchItem = 0;\n        } else { // there is already an active search item\n          halt(event);\n          return clickEmoji(state.currentEmojis[state.activeSearchItem].id)\n        }\n    }\n  }\n\n  //\n  // Handle user input on nav\n  //\n\n  function onNavClick (event) {\n    const { target } = event;\n    const closestTarget = target.closest('.nav-button');\n    /* istanbul ignore if */\n    if (!closestTarget) {\n      return // This should never happen, but makes me nervous not to have it\n    }\n    const groupId = parseInt(closestTarget.dataset.groupId, 10);\n    refs.searchElement.value = ''; // clear search box input\n    state.rawSearchText = '';\n    state.searchText = '';\n    state.activeSearchItem = -1;\n    state.currentGroupIndex = state.groups.findIndex(_ => _.id === groupId);\n  }\n\n  function onNavKeydown (event) {\n    const { target, key } = event;\n\n    const doFocus = el => {\n      if (el) {\n        halt(event);\n        el.focus();\n      }\n    };\n\n    switch (key) {\n      case 'ArrowLeft':\n        return doFocus(target.previousElementSibling)\n      case 'ArrowRight':\n        return doFocus(target.nextElementSibling)\n      case 'Home':\n        return doFocus(target.parentElement.firstElementChild)\n      case 'End':\n        return doFocus(target.parentElement.lastElementChild)\n    }\n  }\n\n  //\n  // Handle user input on an emoji\n  //\n\n  async function clickEmoji (unicodeOrName) {\n    const emoji = await state.database.getEmojiByUnicodeOrName(unicodeOrName);\n    const emojiSummary = [...state.currentEmojis, ...state.currentFavorites]\n      .find(_ => (_.id === unicodeOrName));\n    const skinTonedUnicode = emojiSummary.unicode && unicodeWithSkin(emojiSummary, state.currentSkinTone);\n    await state.database.incrementFavoriteEmojiCount(unicodeOrName);\n    fireEvent('emoji-click', {\n      emoji,\n      skinTone: state.currentSkinTone,\n      ...(skinTonedUnicode && { unicode: skinTonedUnicode }),\n      ...(emojiSummary.name && { name: emojiSummary.name })\n    });\n  }\n\n  async function onEmojiClick (event) {\n    const { target } = event;\n    /* istanbul ignore if */\n    if (!target.classList.contains('emoji')) {\n      // This should never happen, but makes me nervous not to have it\n      return\n    }\n    halt(event);\n    const id = target.id.substring(4); // replace 'emo-' or 'fav-' prefix\n\n    /* no await */ clickEmoji(id);\n  }\n\n  //\n  // Handle user input on the skintone picker\n  //\n\n  function changeSkinTone (skinTone) {\n    state.currentSkinTone = skinTone;\n    state.skinTonePickerExpanded = false;\n    focus('skintone-button');\n    fireEvent('skin-tone-change', { skinTone });\n    /* no await */ state.database.setPreferredSkinTone(skinTone);\n  }\n\n  function onSkinToneOptionsClick (event) {\n    const { target: { id } } = event;\n    const match = id && id.match(/^skintone-(\\d)/); // skintone option format\n    /* istanbul ignore if */\n    if (!match) { // not a skintone option\n      return // This should never happen, but makes me nervous not to have it\n    }\n    halt(event);\n    const skinTone = parseInt(match[1], 10); // remove 'skintone-' prefix\n    changeSkinTone(skinTone);\n  }\n\n  function onClickSkinToneButton (event) {\n    state.skinTonePickerExpanded = !state.skinTonePickerExpanded;\n    state.activeSkinTone = state.currentSkinTone;\n    // this should always be true, since the button is obscured by the listbox, so this `if` is just to be sure\n    if (state.skinTonePickerExpanded) {\n      halt(event);\n      rAF(() => focus('skintone-list'));\n    }\n  }\n\n  // To make the animation nicer, change the z-index of the skintone picker button\n  // *after* the animation has played. This makes it appear that the picker box\n  // is expanding \"below\" the button\n  createEffect(() => {\n    if (state.skinTonePickerExpanded) {\n      refs.skinToneDropdown.addEventListener('transitionend', () => {\n        state.skinTonePickerExpandedAfterAnimation = true; // eslint-disable-line no-unused-vars\n      }, { once: true });\n    } else {\n      state.skinTonePickerExpandedAfterAnimation = false; // eslint-disable-line no-unused-vars\n    }\n  });\n\n  function onSkinToneOptionsKeydown (event) {\n    // this should never happen, but makes me nervous not to have it\n    /* istanbul ignore if */\n    if (!state.skinTonePickerExpanded) {\n      return\n    }\n    const changeActiveSkinTone = async nextSkinTone => {\n      halt(event);\n      state.activeSkinTone = nextSkinTone;\n    };\n\n    switch (event.key) {\n      case 'ArrowUp':\n        return changeActiveSkinTone(incrementOrDecrement(true, state.activeSkinTone, state.skinTones))\n      case 'ArrowDown':\n        return changeActiveSkinTone(incrementOrDecrement(false, state.activeSkinTone, state.skinTones))\n      case 'Home':\n        return changeActiveSkinTone(0)\n      case 'End':\n        return changeActiveSkinTone(state.skinTones.length - 1)\n      case 'Enter':\n        // enter on keydown, space on keyup. this is just how browsers work for buttons\n        // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n        halt(event);\n        return changeSkinTone(state.activeSkinTone)\n      case 'Escape':\n        halt(event);\n        state.skinTonePickerExpanded = false;\n        return focus('skintone-button')\n    }\n  }\n\n  function onSkinToneOptionsKeyup (event) {\n    // this should never happen, but makes me nervous not to have it\n    /* istanbul ignore if */\n    if (!state.skinTonePickerExpanded) {\n      return\n    }\n    switch (event.key) {\n      case ' ':\n        // enter on keydown, space on keyup. this is just how browsers work for buttons\n        // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n        halt(event);\n        return changeSkinTone(state.activeSkinTone)\n    }\n  }\n\n  async function onSkinToneOptionsFocusOut (event) {\n    // On blur outside of the skintone listbox, collapse the skintone picker.\n    const { relatedTarget } = event;\n    // The `else` should never happen, but makes me nervous not to have it\n    /* istanbul ignore else */\n    if (!relatedTarget || relatedTarget.id !== 'skintone-list') {\n      state.skinTonePickerExpanded = false;\n    }\n  }\n\n  function onSearchInput (event) {\n    state.rawSearchText = event.target.value;\n  }\n\n  return {\n    $set (newState) {\n      assign(state, newState);\n    },\n    $destroy () {\n      abortController.abort();\n    }\n  }\n}\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\nvar enI18n = {\n  categoriesLabel: 'Categories',\n  emojiUnsupportedMessage: 'Your browser does not support color emoji.',\n  favoritesLabel: 'Favorites',\n  loadingMessage: 'Loadingâ€¦',\n  networkErrorMessage: 'Could not load emoji.',\n  regionLabel: 'Emoji picker',\n  searchDescription: 'When search results are available, press up or down to select and enter to choose.',\n  searchLabel: 'Search',\n  searchResultsLabel: 'Search results',\n  skinToneDescription: 'When expanded, press up or down to select and enter to choose.',\n  skinToneLabel: 'Choose a skin tone (currently {skinTone})',\n  skinTonesLabel: 'Skin tones',\n  skinTones: [\n    'Default',\n    'Light',\n    'Medium-Light',\n    'Medium',\n    'Medium-Dark',\n    'Dark'\n  ],\n  categories: {\n    custom: 'Custom',\n    'smileys-emotion': 'Smileys and emoticons',\n    'people-body': 'People and body',\n    'animals-nature': 'Animals and nature',\n    'food-drink': 'Food and drink',\n    'travel-places': 'Travel and places',\n    activities: 'Activities',\n    objects: 'Objects',\n    symbols: 'Symbols',\n    flags: 'Flags'\n  }\n};\n\nvar baseStyles = \":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}\";\n\nconst PROPS = [\n  'customEmoji',\n  'customCategorySorting',\n  'database',\n  'dataSource',\n  'i18n',\n  'locale',\n  'skinToneEmoji',\n  'emojiVersion'\n];\n\n// Styles injected ourselves, so we can declare the FONT_FAMILY variable in one place\nconst EXTRA_STYLES = `:host{--emoji-font-family:${FONT_FAMILY}}`;\n\nclass PickerElement extends HTMLElement {\n  constructor (props) {\n    super();\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    style.textContent = baseStyles + EXTRA_STYLES;\n    this.shadowRoot.appendChild(style);\n    this._ctx = {\n      // Set defaults\n      locale: DEFAULT_LOCALE,\n      dataSource: DEFAULT_DATA_SOURCE,\n      skinToneEmoji: DEFAULT_SKIN_TONE_EMOJI,\n      customCategorySorting: DEFAULT_CATEGORY_SORTING,\n      customEmoji: null,\n      i18n: enI18n,\n      emojiVersion: null,\n      ...props\n    };\n    // Handle properties set before the element was upgraded\n    for (const prop of PROPS) {\n      if (prop !== 'database' && Object.prototype.hasOwnProperty.call(this, prop)) {\n        this._ctx[prop] = this[prop];\n        delete this[prop];\n      }\n    }\n    this._dbFlush(); // wait for a flush before creating the db, in case the user calls e.g. a setter or setAttribute\n  }\n\n  connectedCallback () {\n    // The _cmp may be defined if the component was immediately disconnected and then reconnected. In that case,\n    // do nothing (preserve the state)\n    if (!this._cmp) {\n      this._cmp = createRoot(this.shadowRoot, this._ctx);\n    }\n  }\n\n  disconnectedCallback () {\n    // Check in a microtask if the element is still connected. If so, treat this as a \"move\" rather than a disconnect\n    // Inspired by Vue: https://vuejs.org/guide/extras/web-components.html#building-custom-elements-with-vue\n    qM(() => {\n      // this._cmp may be defined if connect-disconnect-connect-disconnect occurs synchronously\n      if (!this.isConnected && this._cmp) {\n        this._cmp.$destroy();\n        this._cmp = undefined;\n\n        const { database } = this._ctx;\n        database.close()\n          // only happens if the database failed to load in the first place, so we don't care\n          .catch(err => console.error(err));\n      }\n    });\n  }\n\n  static get observedAttributes () {\n    return ['locale', 'data-source', 'skin-tone-emoji', 'emoji-version'] // complex objects aren't supported, also use kebab-case\n  }\n\n  attributeChangedCallback (attrName, oldValue, newValue) {\n    this._set(\n      // convert from kebab-case to camelcase\n      // see https://github.com/sveltejs/svelte/issues/3852#issuecomment-665037015\n      attrName.replace(/-([a-z])/g, (_, up) => up.toUpperCase()),\n      // convert string attribute to float if necessary\n      attrName === 'emoji-version' ? parseFloat(newValue) : newValue\n    );\n  }\n\n  _set (prop, newValue) {\n    this._ctx[prop] = newValue;\n    if (this._cmp) {\n      this._cmp.$set({ [prop]: newValue });\n    }\n    if (['locale', 'dataSource'].includes(prop)) {\n      this._dbFlush();\n    }\n  }\n\n  _dbCreate () {\n    const { locale, dataSource, database } = this._ctx;\n    // only create a new database if we really need to\n    if (!database || database.locale !== locale || database.dataSource !== dataSource) {\n      this._set('database', new Database({ locale, dataSource }));\n    }\n  }\n\n  // Update the Database in one microtask if the locale/dataSource change. We do one microtask\n  // so we don't create two Databases if e.g. both the locale and the dataSource change\n  _dbFlush () {\n    qM(() => (\n      this._dbCreate()\n    ));\n  }\n}\n\nconst definitions = {};\n\nfor (const prop of PROPS) {\n  definitions[prop] = {\n    get () {\n      if (prop === 'database') {\n        // in rare cases, the microtask may not be flushed yet, so we need to instantiate the DB\n        // now if the user is asking for it\n        this._dbCreate();\n      }\n      return this._ctx[prop]\n    },\n    set (val) {\n      if (prop === 'database') {\n        throw new Error('database is read-only')\n      }\n      this._set(prop, val);\n    }\n  };\n}\n\nObject.defineProperties(PickerElement.prototype, definitions);\n\n/* istanbul ignore else */\nif (!customElements.get('emoji-picker')) { // if already defined, do nothing (e.g. same script imported twice)\n  customElements.define('emoji-picker', PickerElement);\n}\n\nexport { PickerElement as default };\n"],"names":["assertNonEmptyString","str","Error","assertNumber","number","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","INDEX_TOKENS","INDEX_COUNT","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","uniqEmoji","emojis","arr","func","set","Set","res","item","key","has","add","push","uniqBy","_","unicode","openIndexedDBRequests","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","async","createDatabase","dbName","db","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","initialMigration","onclose","closeDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","normalizeTokens","length","callStore","method","target","getIDB","getAllIDB","commit","findCommonMembers","arrays","uniqByFunc","shortestArray","array","minItem","i","minBy","results","some","findIndex","loadData","emojiData","url","eTag","transformedData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","transformEmojiData","emojiStore","metaStore","oldETag","oldUrl","todo","checkFetched","clear","data","put","getEmojiBySearchQuery","query","intermediateResults","onDone","a","b","token","range","IDBKeyRange","bound","only","index","getEmojiByShortcode","shortcode","predicate","includes","lastKey","processNextBatch","getAll","lowerBound","doFullDatabaseScanForSingleResult","get","requiredKeys$1","customEmojiIndex","customEmojis","isArray","Array","firstItemIsFaulty","assertCustomEmojis","sortByName","all","searchTrie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","exact","queue","entriesSortedByKey","shift","value","trie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","search","byShortcode","byName","isFirefoxContentScript","wrappedJSObject","cleanEmoji","structuredClone","len","requiredKeys","assertStatus","response","dataSource","Math","floor","status","getETagAndData","fetch","headers","json","assertEmojiData","jsonChecksum","object","inBuffer","binary","buf","ArrayBuffer","Uint8Array","charCodeAt","binaryStringToArrayBuffer","JSON","stringify","outBinString","buffer","bytes","byteLength","String","fromCharCode","arrayBufferToBinaryString","crypto","subtle","digest","btoa","checkForUpdates","getETag","eTagAndData","hasData","Database","constructor","locale","this","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","addOnCloseListener","empty","isEmpty","loadDataForFirstTime","ready","checkReady","getEmojiByGroup","custom","getEmojiByUnicodeOrName","unicodeOrName","getEmojiByUnicode","getPreferredSkinTone","setPreferredSkinTone","skinTone","incrementFavoriteEmojiCount","getTopFavoriteEmoji","limit","favoritesStore","openCursor","cursor","addResult","continue","primaryKey","_shutdown","err","deleteDatabase","allGroups","id","groups","slice","rIC","requestIdleCallback","setTimeout","hasZwj","versionsAndTestEmoji","MOST_COMMONLY_USED_EMOJI","FONT_FAMILY","DEFAULT_CATEGORY_SORTING","getTextFeature","text","color","canvas","document","createElement","width","height","ctx","getContext","textBaseline","font","fillStyle","scale","fillText","getImageData","testColorEmojiSupported","feature1","feature2","feature1Str","join","startsWith","compareFeatures","promise","detectEmojiSupportLevel","determineEmojiSupportLevel","supportedZwjEmojis","halt","event","preventDefault","stopPropagation","incrementOrDecrement","decrement","val","rAF","requestAnimationFrame","baselineEmojiWidth","resizeObserverSupported","ResizeObserver","calculateTextWidth","node","createRange","selectNode","firstChild","getBoundingClientRect","getFromMap","cache","cached","toString","parseCache","WeakMap","domInstancesCache","unkeyedSymbol","Symbol","hasReplaceChildren","Element","prototype","patchChildren","newChildren","instanceBinding","targetNode","targetParentNode","needsRerender","parentNode","oldChild","oldChildrenCount","nextSibling","doChildrenNeedRerender","replaceChildren","innerHTML","append","parse","htmlString","withinTag","withinAttribute","elementIndexCounter","elementsToBindings","elementIndexes","j","pop","bindings","attributeName","attributeValuePre","attributeValuePost","exec","binding","expressionIndex","template","parseTemplate","parseHtml","dom","cloneNode","content","firstElementChild","instanceBindings","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","element","elementIndex","currentExpression","nextNode","traverseAndSetupBindings","expressions","expression","setAttribute","newNode","replaceWith","nodeValue","patch","render","container","state","helpers","events","actions","refs","abortSignal","firstRender","labelWithSkin","titleForEmoji","unicodeWithSkin","html","domInstances","domInstanceCacheKey","callback","keyFunction","originalCacheKey","domInstancesForTokens","updateDomInstance","createFramework","emojiList","searchMode","prefix","activeSearchItem","currentSkinTone","rootDom","i18n","regionLabel","pickerStyle","searchLabel","currentEmojis","activeSearchItemId","searchDescription","skinTonePickerExpandedAfterAnimation","skinTonePickerExpanded","skinToneButtonLabel","skinToneButtonText","skinToneDescription","skinTonesLabel","activeSkinTone","categoriesLabel","categories","currentGroup","isRtl","currentGroupIndex","message","databaseLoaded","searchResultsLabel","currentEmojisWithCategories","emojiWithCategory","category","favoritesLabel","scrollbarWidth","currentFavorites","appendChild","forElementWithAttribute","querySelectorAll","getAttribute","eventName","listenerName","addEventListener","ref","action","removeChild","qM","queueMicrotask","then","arraysAreEqualByFunction","left","right","areEqualFunc","EMPTY_ARRAY","assign","createRoot","shadowRoot","props","abortController","AbortController","signal","createEffect","currentObserver","destroyed","propsToObservers","dirtyObservers","queued","flush","observersToRun","observer","size","Proxy","prop","observers","newValue","runnable","oldObserver","createState","skinToneEmoji","database","customCategorySorting","emojiVersion","initialLoad","rawSearchText","searchText","defaultFavoriteEmojis","numColumns","focus","getElementById","emojiToDomNode","fireEvent","detail","rootElement","dispatchEvent","CustomEvent","bubbles","composed","compareEmojiArrays","compareCurrentEmojisWithCategories","aCategory","aEmojis","bCategory","bEmojis","updateCurrentEmojis","newEmojis","updateSearchMode","newSearchMode","uniq","onClickSkinToneButton","onEmojiClick","classList","contains","clickEmoji","substring","onNavClick","closestTarget","closest","groupId","parseInt","dataset","searchElement","onNavKeydown","doFocus","el","previousElementSibling","nextElementSibling","parentElement","lastElementChild","onSearchKeydown","goToNextOrPrevious","previous","onSkinToneOptionsClick","changeSkinTone","onSkinToneOptionsFocusOut","relatedTarget","onSkinToneOptionsKeydown","changeActiveSkinTone","nextSkinTone","onSkinToneOptionsKeyup","onSearchInput","calculateEmojiGridStyle","onUpdate","resizeObserver","contentRect","observe","disconnect","calculateWidth","style","getComputedStyle","newNumColumns","getPropertyValue","newIsRtl","newScrollbarWidth","updateCustomEmoji","isZwjSupported","filterEmojisByVersion","emojiSupportLevel","summarizeEmojis","toSimpleSkinsMap","skin","summarizeEmojisForUI","emojiSummary","find","skinTonedUnicode","level","emojiUnsupportedMessage","showingLoadingMessage","timeoutHandle","loadingMessage","networkErrorMessage","clearTimeout","fill","zwjIndex","indexOf","fromCodePoint","endsWith","applySkinTone","skinToneLabel","favs","dbFavorites","favorites","getEmojisBySearchQuery","currentGroupId","getEmojisByGroup","zwjEmojisToCheck","baselineEmoji","emojiWidth","supported","checkZwjSupport","checkZwjSupportAndUpdate","tabpanelElement","scrollTop","newEmojisWithCategories","updateCurrentEmojisWithCategories","categoriesToEmoji","calculateCurrentEmojisWithCategories","trim","skinToneDropdown","once","$set","newState","$destroy","abort","enI18n","activities","objects","symbols","flags","PROPS","EXTRA_STYLES","PickerElement","HTMLElement","attachShadow","mode","textContent","_ctx","hasOwnProperty","call","_dbFlush","connectedCallback","_cmp","disconnectedCallback","isConnected","catch","observedAttributes","attributeChangedCallback","attrName","oldValue","_set","up","toUpperCase","parseFloat","_dbCreate","definitions","defineProperties","customElements","define"],"mappings":"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","x_google_ignoreList":[0,1]}