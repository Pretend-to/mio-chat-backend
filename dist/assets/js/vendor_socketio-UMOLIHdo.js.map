{"version":3,"file":"vendor_socketio-UMOLIHdo.js","sources":["../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/on.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/socket.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/contrib/backo2.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/manager.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/index.js","../../../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/url.js"],"sourcesContent":["export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        var _a, _b, _c;\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;\n        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());\n        const discardPacket = this.flags.volatile && !isTransportWritable;\n        if (discardPacket) {\n        }\n        else if (isConnected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n","/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nexport function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n","import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        if (!v) {\n            this.skipReconnect = true;\n        }\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), \n        // @ts-ignore\n        on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called when:\n     *\n     * - the low-level engine is closed\n     * - the parser encountered a badly formatted packet\n     * - all sockets are disconnected\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        var _a;\n        this.cleanup();\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\nexport { Fetch, NodeXHR, XHR, NodeWebSocket, WebSocket, WebTransport, } from \"engine.io-client\";\n","import { parse } from \"engine.io-client\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n"],"names":["on","obj","ev","fn","off","RESERVED_EVENTS","Object","freeze","connect","connect_error","disconnect","disconnecting","newListener","removeListener","Socket","Emitter","constructor","io","nsp","opts","super","this","connected","recovered","receiveBuffer","sendBuffer","_queue","_queueSeq","ids","acks","flags","auth","_opts","assign","_autoConnect","open","disconnected","subEvents","subs","onopen","bind","onpacket","onerror","onclose","active","_readyState","send","args","unshift","emit","apply","_a","_b","_c","hasOwnProperty","Error","toString","retries","fromQueue","volatile","_addToQueue","packet","type","PacketType","EVENT","data","options","compress","length","id","ack","pop","_registerAckCallback","isTransportWritable","engine","transport","writable","isConnected","_hasPingExpired","notifyOutgoingListeners","push","timeout","ackTimeout","timer","setTimeoutFn","i","splice","call","clearTimeoutFn","withError","emitWithAck","Promise","resolve","reject","arg1","arg2","tryCount","pending","err","responseArgs","shift","_drainQueue","force","_packet","_sendConnectPacket","CONNECT","_pid","pid","offset","_lastOffset","emitReserved","reason","description","_clearAcks","keys","forEach","some","String","sid","onconnect","BINARY_EVENT","onevent","ACK","BINARY_ACK","onack","DISCONNECT","ondisconnect","CONNECT_ERROR","destroy","message","emitEvent","_anyListeners","listeners","slice","listener","self","sent","emitBuffered","subDestroy","close","onAny","prependAny","offAny","listenersAny","onAnyOutgoing","_anyOutgoingListeners","prependAnyOutgoing","offAnyOutgoing","listenersAnyOutgoing","Backoff","ms","min","max","factor","jitter","attempts","prototype","duration","Math","pow","rand","random","deviation","floor","reset","setMin","setMax","setJitter","Manager","uri","nsps","path","installTimerFunctions","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","_parser","parser","encoder","Encoder","decoder","Decoder","autoConnect","v","arguments","_reconnection","skipReconnect","_reconnectionAttempts","_reconnectionDelay","_randomizationFactor","_reconnectionDelayMax","_timeout","maybeReconnectOnOpen","_reconnecting","reconnect","indexOf","Engine","socket","openSubDestroy","onError","cleanup","errorSub","autoUnref","unref","onping","ondata","ondecoded","add","e","nextTick","_destroy","_close","encodedPackets","encode","write","delay","onreconnect","attempt","cache","lookup","parsed","loc","location","protocol","host","charAt","test","parse","port","href","url","source","sameNamespace","forceNew","multiplex","query","queryKey"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}